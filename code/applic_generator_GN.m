function [incoming,adjacency,commun_vol,incoming_possible_shapes,incoming_num_of_possible_shapes] = applic_generator_GN()

% Function applic_generator_GN creates applications with parameters
% specified by the global variables listed below.  Returns applications in
% "incoming", edges between tasks in "adjacency" (undirected graph),
% weights for edges in "commun_vol",
% possible shapes for each task in "incoming_possible_shapes".

% adapted from March 2013 version of task_generator.m and July 2013 version
% of applic_generator_AR.m

% To handle different communication volume between different pairs of
% tasks, this  function builds a matrix of weights called
% "commun_vol" with one weight for each undirected edge.
% Have the option of generating all weights same ("same_commun_vol"
% = 1) or randomly generating over a range ("same_commun_vol" = 0 and
% variables "min_commun_vol" and "max_commun_vol" defining the upper
% and lower limits for uniform random distribution of weights).


global chip_width chip_height num_of_applications min_task_per_application max_task_per_application 
global edge_ratio prime_option_less prime_option_more non_prime_option_less non_prime_option_more width_max_fraction height_max_fraction
global arrival_time_max max_execution_time
global same_commun_vol min_commun_vol max_commun_vol
global min_laxity max_laxity

%  Moved the following clearing actions up to "runGN"
%clear incoming adjacency commun_vol incoming_possible_shapes incoming_num_of_possible_shapes;
%clc


% incoming array consists of the following columns
% (with one row per application):
% * Application ID
% * number_of_tasks
% * Arrival time
% * Execution_Time
% * Deadline

% for each application the communication between its tasks will be stored
% in a 1 x num_of_applications CELL ARRAY called "adjacency"
% each element of the cell array consists of a matrix of n x (n+1) size
% where n is the number of tasks in the application.
% Entry (i,1) holds the task ID
% Entry (i,j), for j>1, holds element (i,j-1) of the adjacency array, where
% each element has a value of 0 or 1. and 0 means  no
% communication between the two tasks, 1 means there is communication.

% A corresponding array "commun_vol" that holds in each matrix
% entry (i,j), for j>1, equal to the communication volume between
%  task i and task j-1.

% Note:  Function "mapper_GN" will append two columns to each of
%  "adjacency" and "commun_vol", where column n+2 holds the number
%  of edges incident on each task and column n+3 holds the sum
%  of communication volumes on all edges incident on each task


% initialization 
incoming(:,5) = 0;
adjacency = cell (1,num_of_applications);
commun_vol = cell (1,num_of_applications);


% this program assumes for simplicity without loss of generality that
% tasks are stored in the incoming application array before the program
% starts and total number of applications is known. this assumption is because i
% have no way to have two programs running at same time one to generate
% tasks randomly and this program 

%**************************************************************************
%intializing the incoming array
% 1- incoming array 
%      contains newely arrived Applications.
%               (Application_ID num_of_tasks arrival_time execution_time deadline)

for i = 1 : num_of_applications
    while (true)
        incoming(i,1) = i; % insert task ID



        % this code will randomize the num_of_tasks in each application and also
        % will generate all parameters corresponding to each application


        % generate the num of tasks in each application
         incoming(i,2) = randi ([min_task_per_application,max_task_per_application],1,1);
        % generate the arrival time of each application
        incoming(i,3) = randi ([0,arrival_time_max],1,1);  

        % generate the execution time of each application
         incoming(i,4) = randi ([5,max_execution_time],1,1);
         
        % generate the deadline time of each application
        % the deadline will be generated by adding the arrival time,execution time
        % and a random value generated between ( min laxity and max laxity)
        laxity = randi ([min_laxity,max_laxity],1,1);
        incoming(i,5) =  incoming(i,3) + incoming(i,4) + laxity;  %generate random deadline for the tasks   

        %incoming = sortrows(incoming,3);


        % after generating the incoming array, we will have a problem with some
        % application sizes that need to be modified. for example if we have an
        % application size of 101, this is a prime number that will only be
        % available in two forms: 1*101 or 101*1 and in both cases this application
        % will not be placed on the chip becuase in the two cases either the hieght
        % or the width is higher than the chip height or width.
        % the code will modify the application size in this part of the code by
        % adding extra dummy tasks ( in this version of the code it will be
        % considered as a real task)
        % to the application to allow for placement. this
        % is an extra load to the scheduler but it is necessary for a better
        % performance regarding the rejection ratio.

        % for a prime application size that is less than the chip width the code
        % will have two options:
        % option number 1: run as is  
        % option number 2: the code will change the application size by inserting
        % one dummy task and will limit the application placement size to the
        % required percentage.
        % prime_option_less is a variable to choose between the two options


        % for a non-prime application size that is less than the chip_width the
        % code will have two options:
        % option 1 : run as is
        % option 2: the code will leave the application size as is and will limit 
        % the application placement size to the required percentage.
        % non_prime_option_less is a variable to choose between the two options

        % for prime application size that is more than the chip width the code will
        % have two options:
        % option 1 : run as is (all these applications will be rejected)
        % option 2 : the application size will be increased by one dummy task and
        % the application placement size will be limited to the required percentage
        % of the chip width
        % prime_option_more is a variable to choose between the two options 

        % for a non-prime application size that is more than the chip_width the
        % code will have two options:
        % option 1 : run as is
        % option 2: the code will leave the application size as is and will limit 
        % the application placement size to the required percentage.
        % non_prime_option_more is a variable to choose between the two options



        % initialize incoming_possible_shapes Cell array
        % incoming_possible_shapes{1,i} is an array of of three cols -- the first two
        % are the width and height and the third col will be used later in the
        % scheduler to store the communication cost for each possible shape.
        % as an example if an application i has 8 tasks then
        % incoming_possible_shapes{1,i} will equal the following after the end of
        % applic_generator
        % 1 8 0
        % 2 4 0
        % 4 2 0
        % 8 1 0
        % if the user sets the sorting variable to 1 then it will equal
        % 2 4 0
        % 4 2 0 
        % 1 8 0
        % 8 1 0

        incoming_possible_shapes{1,i} = 0;
        incoming_num_of_possible_shapes(i) = 0;

        % The following line calls find_possible_shapes to determine whether
        %   the number of tasks in an application is prime.
        %   If and only if this number is prime, the number of shapes
        %   will be 2.
        [temp,num_of_possible_shapes] = find_possible_shapes(incoming(i,2));
        if num_of_possible_shapes == 2 %(prime number case)
            % case 1 : application size < chip_width
            if incoming (i,2) <= chip_width
                if prime_option_less == 1
                    % run as is
                    [incoming_possible_shapes{1,i},incoming_num_of_possible_shapes(i)] = find_possible_shapes(incoming(i,2));
                elseif prime_option_less == 2
                    % Increase number of tasks by 1 to make non-prime, then
                    % limit the shape width and height to a percentage of
                    % the chip width and height by discarding shapes that
                    % are too wide or high
                    incoming(i,2) = incoming(i,2) +1;
                    [temp,num_of_possible_shapes] = find_possible_shapes(incoming(i,2));
                    for j = num_of_possible_shapes : -1 : 1
                        if (temp(j,1) > ceil(width_max_fraction*chip_width)) || (temp(j,2) > ceil(height_max_fraction*chip_height)) 
                            temp(j,:) = [];
                        end
                    end
                    incoming_possible_shapes{1,i} = temp;
                    incoming_num_of_possible_shapes(i) = size(temp,1);
                end
            else
                if prime_option_more == 1
                    % run as is
                    [incoming_possible_shapes{1,i},incoming_num_of_possible_shapes(i)] = find_possible_shapes(incoming(i,2));                
                elseif prime_option_more == 2
                    % Increase number of tasks by 1 to make non-prime, then
                    % limit the shape width and height to a percentage of
                    % the chip width and height by discarding shapes that
                    % are too wide or high
                    incoming(i,2) = incoming(i,2) +1;
                    [temp,num_of_possible_shapes] = find_possible_shapes(incoming(i,2));
                    for j =  num_of_possible_shapes : -1 : 1
                        if (temp(j,1) > ceil(width_max_fraction*chip_width)) || (temp(j,2) > ceil(height_max_fraction*chip_height)) 
                            temp(j,:) = [];
                        end
                    end
                    incoming_possible_shapes{1,i} = temp;
                    incoming_num_of_possible_shapes(i) = size(temp,1);
                end
            end
        else % non prime case
            % case 1 : application size < chip_width
            if incoming (i,2) <= chip_width
                if non_prime_option_less == 1 
                    % run as is
                    [incoming_possible_shapes{1,i},incoming_num_of_possible_shapes(i)] = find_possible_shapes(incoming(i,2));
               elseif non_prime_option_less == 2
                    % limit the shape width and height to a percentage of
                    % the chip width and height by discarding shapes that
                    % are too wide or high
                    [temp,num_of_possible_shapes] = find_possible_shapes(incoming(i,2));
                    for j = num_of_possible_shapes : -1 : 1
                        if (temp(j,1) > ceil(width_max_fraction*chip_width)) || (temp(j,2) > ceil(height_max_fraction*chip_height)) 
                            temp(j,:) = [];
                        end
                    end
                    incoming_possible_shapes{1,i} = temp;
                    incoming_num_of_possible_shapes(i) = size(temp,1);
                end
            else
                if non_prime_option_more == 1
                    % run as is
                    [incoming_possible_shapes{1,i},incoming_num_of_possible_shapes(i)] = find_possible_shapes(incoming(i,2));                
                elseif non_prime_option_more == 2
                    % limit the shape width and height to a percentage of
                    % the chip width and height by discarding shapes that
                    % are too wide or high
                    [temp,num_of_possible_shapes] = find_possible_shapes(incoming(i,2));
                    for j = num_of_possible_shapes : -1 : 1
                        if (temp(j,1) > ceil(width_max_fraction*chip_width)) || (temp(j,2) > ceil(height_max_fraction*chip_height)) 
                            temp(j,:) = [];
                        end
                    end
                    incoming_possible_shapes{1,i} = temp;
                    incoming_num_of_possible_shapes(i) = size(temp,1);
                end
            end
        end
        if incoming_num_of_possible_shapes(i) > 0
            break;
        end
    end
end


% sorting incoming array based on arrival time

    for i = 1 : num_of_applications
        for j = i+1 : num_of_applications
            if incoming(i,3) > incoming(j,3)

                temp = incoming(i,:);
                incoming(i,:) = incoming(j,:);
                incoming(j,:) = temp;

                temp = incoming_num_of_possible_shapes(i);
                incoming_num_of_possible_shapes(i) = incoming_num_of_possible_shapes(j);
                incoming_num_of_possible_shapes(j) = temp;

                temp = incoming_possible_shapes{i};
                incoming_possible_shapes{i} = incoming_possible_shapes{j};
                incoming_possible_shapes{j} = temp;
            end
        end
    end
%
% the next part of the code is responsible for generating the communication
% pattern within each application.
% will randomize the communication between them based on
% "edge_ratio". This ratio = number of edges : number of tasks.
% For example if "edge_ratio" = 0.5 in an application of 10 tasks, then
% we have 5 communication edges (because undirected, then this means
% 5 pairs of communicating tasks).

% this part will be implemented by calculating the number of communication
% links first and inside the for loop two numbers will randomly generated
% representing the two communicating tasks and then the corresponding
% element in "adjacency" will be set to 1. all other elements
% will be set to 0.
%    Also within the loop, "commun_vol" will initialize the communication
%    volume on each edge.  Will have two copies of the loop, one when all
%    volumes are the same (and so set to 1 by simply copying
%    "adjacency" into "commun_vol") and one when the volumes are random
%    within a given range.

% To convert the original code from generating a directed graph to
%  generating an undirected graph, when the original code generates
%  an edge by setting temp(x,y) = 1, then also set temp(y,x) = 1.
% So the original code generated, say, z directed edges and the 
%  revised code will generate z undirected edges, in effect, twice as
%  many edges as before.


if same_commun_vol == 1
    % In this case, all communication volumes = 1, so
    % matrix "commun_vol" will equal matrix "adjacency"
    %
    % initialize Adjacency Cell array
    for i = 1 : num_of_applications
        adjacency{1,i} = zeros(incoming(i,2));
        commun_vol{1,i} = zeros(incoming(i,2));
    end

    for i = 1 : num_of_applications
        for k = 1 : incoming(i,2)
            for m = 1 : incoming(i,2)
                    temp(k,m) = 0;
            end
        end
        
        for j = 1 : fix((edge_ratio * incoming(i,2)))

            % the first communicating task
            x = randi([1,incoming(i,2)],1,1);
            % the second communicating task (has to be different than the first
            % task.
            y = x;
            while y == x
                y = randi([1,incoming(i,2)],1,1) ;
            end
            % make sure that this link was not chosen before, if it was chosen
            % before the code will repeat this trial.
            if temp(x,y) == 0
                temp (x,y) = 1;
                temp (y,x) = 1;
            else
                j=j-1;
            end
        end
        adjacency{1,i} = [(1:incoming(i,2))' , temp];
        commun_vol{1,i} = [(1:incoming(i,2))' , temp];
        clear temp;
    end

else
    % In this case, communication volumes are random, so
    % generate each entry of matrix "commun_vol" 
    % when generate a 1 entry in matrix "adjacency"
    %
    % initialize Adjacency Cell array
    for i = 1 : num_of_applications
        adjacency{1,i} = zeros(incoming(i,2));
        commun_vol{1,i} = zeros(incoming(i,2));
    end

    for i = 1 : num_of_applications
        for k = 1 : incoming(i,2)
            for m = 1 : incoming(i,2)
                    temp(k,m) = 0;
                    temp2(k,m) = 0;
            end
        end
        
        for j = 1 : fix((edge_ratio * incoming(i,2)))

            % the first communicating task
            x = randi([1,incoming(i,2)],1,1);
            % the second communicating task (has to be different than the first
            % task)
            y = x;
            while y == x
                y = randi([1,incoming(i,2)],1,1) ;
            end
              % randomly generate communication volume for
              %   undirected edge -- includes both directions
            temp_vol = randi([min_commun_vol,max_commun_vol],1,1);
            % make sure that this link was not chosen before, if it was chosen
            % before the code will repeat this trial.
            if temp(x,y) == 0
                temp (x,y) = 1;
                temp (y,x) = 1;
                temp2 (x,y) = temp_vol;
                temp2 (y,x) = temp_vol;
            else
                j=j-1;
            end
        end
        adjacency{1,i} = [(1:incoming(i,2))' , temp];
        commun_vol{1,i} = [(1:incoming(i,2))' , temp2];
        clear temp;
        clear temp2;
        clear temp_vol;
    end
end
save('commun_vol1.mat','commun_vol','-v7.3')

end



